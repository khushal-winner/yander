[
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "035769d6-7665-4428-ada5-91d04f0b165d",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC001-post auth register user registration with valid data",
    "description": "Test the POST /auth/register endpoint with valid email, password, and name to ensure it returns 201 status with user object and access and refresh tokens.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_post_auth_register_user_registration_with_valid_data():\n    url = f\"{BASE_URL}/auth/register\"\n    # Unique email to avoid duplicate error in case of rerun\n    unique_email = f\"test_user_{uuid.uuid4().hex[:8]}@example.com\"\n    payload = {\n        \"email\": unique_email,\n        \"password\": \"StrongPassword123!\",\n        \"name\": \"Test User\"\n    }\n    headers = {\"Content-Type\": \"application/json\"}\n\n    response = None\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        assert response.status_code == 201, f\"Expected 201 Created, got {response.status_code}\"\n        json_resp = response.json()\n        # Check user object keys\n        assert \"user\" in json_resp, \"Response missing 'user'\"\n        user = json_resp[\"user\"]\n        assert isinstance(user, dict), \"'user' is not a dict\"\n        assert \"email\" in user and user[\"email\"] == unique_email, \"User email mismatch\"\n        assert \"id\" in user, \"User object missing 'id'\"\n\n        # Check tokens\n        assert \"accessToken\" in json_resp, \"Missing accessToken\"\n        assert isinstance(json_resp[\"accessToken\"], str) and len(json_resp[\"accessToken\"]) > 0, \"Invalid accessToken\"\n        assert \"refreshToken\" in json_resp, \"Missing refreshToken\"\n        assert isinstance(json_resp[\"refreshToken\"], str) and len(json_resp[\"refreshToken\"]) > 0, \"Invalid refreshToken\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n    finally:\n        # Cleanup: delete the created user by login + revoke or direct delete if possible\n        # Since no delete user endpoint auth is defined and auth for DELETE /users/:id is false,\n        # we can delete the user directly by id (from response user.id)\n        if response and response.status_code == 201:\n            user_id = json_resp[\"user\"].get(\"id\")\n            if user_id:\n                try:\n                    del_url = f\"{BASE_URL}/users/{user_id}\"\n                    del_response = requests.delete(del_url, timeout=TIMEOUT)\n                    assert del_response.status_code == 204, f\"User cleanup failed with status {del_response.status_code}\"\n                except requests.RequestException:\n                    # Just pass - cleanup best effort\n                    pass\n\ntest_post_auth_register_user_registration_with_valid_data()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 52, in <module>\n  File \"<string>\", line 21, in test_post_auth_register_user_registration_with_valid_data\nAssertionError: Expected 201 Created, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.130Z",
    "modified": "2026-02-18T12:37:51.825Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "fa54a43e-790d-4c4a-bc7c-42cce38cac0c",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC002-post auth login user login with valid credentials",
    "description": "Test the POST /auth/login endpoint with correct email and password to verify it returns 200 status with access and refresh tokens.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_post_auth_login_valid_credentials():\n    url = f\"{BASE_URL}/auth/login\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    payload = {\n        \"email\": \"test@test.com\",\n        \"password\": \"test\"  # Assuming password is \"test\" because only email given; use a correct known test password\n    }\n    \n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n    except requests.RequestException as e:\n        assert False, f\"Request to {url} failed: {e}\"\n    \n    assert response.status_code == 200, f\"Expected status 200, got {response.status_code}, response: {response.text}\"\n    try:\n        data = response.json()\n    except ValueError:\n        assert False, \"Response is not valid JSON\"\n\n    # Validate presence of accessToken and refreshToken in response\n    assert isinstance(data, dict), f\"Response JSON should be an object, got {type(data)}\"\n    assert \"accessToken\" in data, \"Response JSON missing 'accessToken'\"\n    assert isinstance(data[\"accessToken\"], str) and data[\"accessToken\"], \"'accessToken' should be non-empty string\"\n    assert \"refreshToken\" in data, \"Response JSON missing 'refreshToken'\"\n    assert isinstance(data[\"refreshToken\"], str) and data[\"refreshToken\"], \"'refreshToken' should be non-empty string\"\n\ntest_post_auth_login_valid_credentials()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 34, in <module>\n  File \"<string>\", line 21, in test_post_auth_login_valid_credentials\nAssertionError: Expected status 200, got 404, response: {\"error\":\"Route not found\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.137Z",
    "modified": "2026-02-18T12:37:51.820Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "6274460e-df89-4866-8ab6-1a730988a0e2",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC003-get auth me fetch current user information",
    "description": "Test the GET /auth/me endpoint with a valid access token in Authorization header to ensure it returns 200 status with the current user object.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nREGISTER_ENDPOINT = \"/auth/register\"\nLOGIN_ENDPOINT = \"/auth/login\"\nAUTH_ME_ENDPOINT = \"/auth/me\"\nTIMEOUT = 30\n\ndef test_get_auth_me_fetch_current_user_information():\n    # User credentials for registration and login\n    user_data = {\n        \"email\": \"test@test.com\",\n        \"password\": \"TestPassword123!\",\n        \"name\": \"Test User\"\n    }\n\n    access_token = None\n    refresh_token = None\n\n    try:\n        # Register user\n        reg_resp = requests.post(\n            BASE_URL + REGISTER_ENDPOINT,\n            json=user_data,\n            timeout=TIMEOUT\n        )\n        if reg_resp.status_code != 201 and reg_resp.status_code != 400:\n            reg_resp.raise_for_status()\n        # If user already registered (400), continue to login\n\n        # Login user\n        login_resp = requests.post(\n            BASE_URL + LOGIN_ENDPOINT,\n            json={\"email\": user_data[\"email\"], \"password\": user_data[\"password\"]},\n            timeout=TIMEOUT\n        )\n        assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}: {login_resp.text}\"\n        login_data = login_resp.json()\n        assert \"accessToken\" in login_data and isinstance(login_data[\"accessToken\"], str)\n        assert \"refreshToken\" in login_data and isinstance(login_data[\"refreshToken\"], str)\n        access_token = login_data[\"accessToken\"]\n        refresh_token = login_data[\"refreshToken\"]\n\n        # Get current user info using access token\n        headers = {\"Authorization\": f\"Bearer {access_token}\"}\n        auth_me_resp = requests.get(\n            BASE_URL + AUTH_ME_ENDPOINT,\n            headers=headers,\n            timeout=TIMEOUT\n        )\n        assert auth_me_resp.status_code == 200, f\"GET /auth/me failed with status {auth_me_resp.status_code}: {auth_me_resp.text}\"\n        user_obj = auth_me_resp.json()\n        assert isinstance(user_obj, dict), \"Response is not a JSON object\"\n        # Basic checks on user object\n        assert \"email\" in user_obj and user_obj[\"email\"] == user_data[\"email\"]\n        assert \"name\" in user_obj and user_obj[\"name\"] == user_data[\"name\"]\n        assert \"id\" in user_obj and isinstance(user_obj[\"id\"], (int, str))\n\n    finally:\n        # Cleanup: If registered via this test (not guaranteed), try to delete the user by logging in and calling DELETE user API if available\n        # There is no DELETE user endpoint auth_required false in PRD, so skip actual deletion to avoid accidental removal\n        pass\n\ntest_get_auth_me_fetch_current_user_information()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 28, in test_get_auth_me_fetch_current_user_information\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/auth/register\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.143Z",
    "modified": "2026-02-18T12:37:50.568Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "e8e51351-6245-4d6b-84d0-303508198a59",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC004-post auth refresh refresh access token using refresh token",
    "description": "Test the POST /auth/refresh endpoint with a valid refresh token to verify it returns 200 status with a new access token.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_post_auth_refresh_refresh_access_token_using_refresh_token():\n    register_url = f\"{BASE_URL}/auth/register\"\n    login_url = f\"{BASE_URL}/auth/login\"\n    refresh_url = f\"{BASE_URL}/auth/refresh\"\n\n    email = \"testuser_refresh@example.com\"\n    password = \"TestPassword123!\"\n    name = \"Test User Refresh\"\n\n    register_data = None\n    login_data = None\n\n    try:\n        # Register user\n        register_payload = {\n            \"email\": email,\n            \"password\": password,\n            \"name\": name\n        }\n        register_resp = requests.post(register_url, json=register_payload, timeout=TIMEOUT)\n        assert register_resp.status_code == 201, f\"User registration failed: {register_resp.text}\"\n        register_data = register_resp.json()\n        refresh_token = register_data.get(\"refreshToken\")\n        assert isinstance(refresh_token, str) and len(refresh_token) > 0, \"Refresh token missing on registration\"\n\n        # Login user\n        login_payload = {\n            \"email\": email,\n            \"password\": password\n        }\n        login_resp = requests.post(login_url, json=login_payload, timeout=TIMEOUT)\n        assert login_resp.status_code == 200, f\"User login failed: {login_resp.text}\"\n        login_data = login_resp.json()\n        refresh_token = login_data.get(\"refreshToken\")\n        assert isinstance(refresh_token, str) and len(refresh_token) > 0, \"Refresh token missing on login\"\n\n        # Use refresh token to get new access token\n        refresh_payload = {\"refreshToken\": refresh_token}\n        refresh_resp = requests.post(refresh_url, json=refresh_payload, timeout=TIMEOUT)\n        assert refresh_resp.status_code == 200, f\"Refresh token request failed: {refresh_resp.text}\"\n        refresh_data = refresh_resp.json()\n        new_access_token = refresh_data.get(\"accessToken\")\n        assert isinstance(new_access_token, str) and len(new_access_token) > 0, \"New access token missing on refresh\"\n    finally:\n        # Cleanup: delete user\n        user_id = None\n        if register_data and 'id' in register_data:\n            user_id = register_data[\"id\"]\n        elif login_data and 'id' in login_data:\n            user_id = login_data[\"id\"]\n        if user_id:\n            delete_url = f\"{BASE_URL}/users/{user_id}\"\n            try:\n                del_resp = requests.delete(delete_url, timeout=TIMEOUT)\n                assert del_resp.status_code in [204, 404]\n            except Exception:\n                pass\n\ntest_post_auth_refresh_refresh_access_token_using_refresh_token()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 64, in <module>\n  File \"<string>\", line 26, in test_post_auth_refresh_refresh_access_token_using_refresh_token\nAssertionError: User registration failed: {\"error\":\"Route not found\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.149Z",
    "modified": "2026-02-18T12:38:03.884Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "44327208-3f98-4e2b-b86f-ebc6ac367b17",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC005-post auth logout invalidate refresh token on logout",
    "description": "Test the POST /auth/logout endpoint with valid access token and refresh token to ensure it returns 200 status with success message and invalidates the refresh token.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_post_auth_logout_invalidate_refresh_token_on_logout():\n    # Test user credentials for auth login\n    email = \"test@test.com\"\n    password = \"TestPassword123!\"\n    # Register the user first to ensure the user exists (if already registered it might fail but we continue)\n    register_payload = {\n        \"email\": email,\n        \"password\": password,\n        \"name\": \"Test User\"\n    }\n    try:\n        requests.post(f\"{BASE_URL}/auth/register\", json=register_payload, timeout=TIMEOUT)\n    except requests.exceptions.RequestException:\n        pass  # If already registered, ignore\n\n    # Login to get access token and refresh token\n    login_payload = {\n        \"email\": email,\n        \"password\": password\n    }\n    login_resp = requests.post(f\"{BASE_URL}/auth/login\", json=login_payload, timeout=TIMEOUT)\n    assert login_resp.status_code == 200, f\"Login failed: {login_resp.text}\"\n    login_data = login_resp.json()\n    access_token = login_data.get(\"accessToken\")\n    refresh_token = login_data.get(\"refreshToken\")\n    assert access_token is not None, \"Missing access token in login response\"\n    assert refresh_token is not None, \"Missing refresh token in login response\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n\n    # Call POST /auth/logout with Authorization header and refreshToken in body\n    logout_payload = {\n        \"refreshToken\": refresh_token\n    }\n    logout_resp = requests.post(f\"{BASE_URL}/auth/logout\", headers=headers, json=logout_payload, timeout=TIMEOUT)\n    assert logout_resp.status_code == 200, f\"Logout failed: {logout_resp.text}\"\n    logout_json = logout_resp.json()\n    # Expect some success message presence (check message key or similar)\n    assert any(key in logout_json for key in (\"message\", \"success\", \"msg\")), \"Success message missing in logout response\"\n\n    # Verify refresh token is invalidated by attempting to refresh token with that refresh token\n    refresh_payload = {\n        \"refreshToken\": refresh_token\n    }\n    refresh_resp = requests.post(f\"{BASE_URL}/auth/refresh\", json=refresh_payload, timeout=TIMEOUT)\n    assert refresh_resp.status_code == 401, f\"Refresh token was not invalidated after logout: {refresh_resp.text}\"\n\ntest_post_auth_logout_invalidate_refresh_token_on_logout()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 56, in <module>\n  File \"<string>\", line 28, in test_post_auth_logout_invalidate_refresh_token_on_logout\nAssertionError: Login failed: {\"error\":\"Route not found\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.154Z",
    "modified": "2026-02-18T12:37:53.060Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "03c66b8a-771f-47a9-9620-5c20c4fc314c",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC006-post users create new user with valid data",
    "description": "Test the POST /users endpoint with valid email and name to verify it returns 201 status with the created user object.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\ndef test_post_users_create_new_user_with_valid_data():\n    url = f\"{BASE_URL}/users\"\n    headers = {\n        \"Content-Type\": \"application/json\"\n    }\n    # Unique email to avoid duplication issues\n    unique_email = f\"testuser_{uuid.uuid4().hex[:8]}@example.com\"\n    payload = {\n        \"email\": unique_email,\n        \"name\": \"Test User\"\n    }\n\n    created_user_id = None\n    try:\n        response = requests.post(url, json=payload, headers=headers, timeout=TIMEOUT)\n        # Assert status code 201 Created\n        assert response.status_code == 201, f\"Expected status 201, got {response.status_code}\"\n        response_json = response.json()\n        # Assert returned user object has email and name matching request\n        assert response_json.get(\"email\") == unique_email, \"Response email mismatch\"\n        assert response_json.get(\"name\") == \"Test User\", \"Response name mismatch\"\n        # Assert user id exists and is not empty\n        assert \"id\" in response_json and response_json[\"id\"], \"User id missing in response\"\n        created_user_id = response_json[\"id\"]\n    finally:\n        # Cleanup: delete created user if created\n        if created_user_id:\n            delete_url = f\"{BASE_URL}/users/{created_user_id}\"\n            try:\n                del_response = requests.delete(delete_url, timeout=TIMEOUT)\n                # Optionally assert 204 deletion success, but ignore errors silently here\n                if del_response.status_code != 204:\n                    print(f\"Warning: Failed to delete user {created_user_id}, status code {del_response.status_code}\")\n            except Exception as e:\n                print(f\"Exception during cleanup delete: {e}\")\n\ntest_post_users_create_new_user_with_valid_data()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 43, in <module>\n  File \"<string>\", line 23, in test_post_users_create_new_user_with_valid_data\nAssertionError: Expected status 201, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.161Z",
    "modified": "2026-02-18T12:37:59.518Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "702a0a3d-1be6-4619-8cd9-1ff0c56d1e4b",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC007-delete users delete user by id",
    "description": "Test the DELETE /users/:id endpoint with an existing user id to ensure it returns 204 No content indicating successful deletion.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8000\"\n\ndef test_delete_user_by_id():\n    timeout = 30\n\n    # Step 1: Create a new user to ensure a user exists for deletion\n    create_user_payload = {\n        \"email\": \"tempuser_delete_test@example.com\",\n        \"name\": \"Temp User Delete Test\"\n    }\n    try:\n        create_resp = requests.post(f\"{BASE_URL}/users\", json=create_user_payload, timeout=timeout)\n        assert create_resp.status_code == 201, f\"User creation failed with status {create_resp.status_code}\"\n        user = create_resp.json()\n        user_id = user.get(\"id\")\n        assert user_id is not None, \"Created user response does not contain 'id'\"\n\n        # Step 2: Delete the user by ID\n        delete_resp = requests.delete(f\"{BASE_URL}/users/{user_id}\", timeout=timeout)\n        assert delete_resp.status_code == 204, f\"User deletion failed with status {delete_resp.status_code}\"\n        assert not delete_resp.content, \"Response content for DELETE /users/:id should be empty\"\n\n        # Step 3: Verify deletion by attempting to delete again (should return 404)\n        delete_again_resp = requests.delete(f\"{BASE_URL}/users/{user_id}\", timeout=timeout)\n        assert delete_again_resp.status_code == 404, f\"Expected 404 when deleting non-existent user, got {delete_again_resp.status_code}\"\n\n    finally:\n        # Cleanup: Attempt to delete user if still exists\n        if 'user_id' in locals():\n            requests.delete(f\"{BASE_URL}/users/{user_id}\", timeout=timeout)\n\ntest_delete_user_by_id()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 34, in <module>\n  File \"<string>\", line 15, in test_delete_user_by_id\nAssertionError: User creation failed with status 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.166Z",
    "modified": "2026-02-18T12:37:55.465Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "4a3cded7-1c84-4f14-8ec0-acfc8b97eced",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC008-get api workspaces list all workspaces for authenticated user",
    "description": "Test the GET /api/workspaces endpoint with a valid access token to verify it returns 200 status with a list of workspaces the user belongs to.",
    "code": "import requests\nimport uuid\n\nBASE_URL = \"http://localhost:8000\"\nTIMEOUT = 30\n\nUSER_EMAIL = \"test@test.com\"\nUSER_PASSWORD = \"TestPassword123!\"\n\ndef test_get_api_workspaces_list_all_workspaces_for_authenticated_user():\n    # Helper function to register a new user - used only if login fails for the test user\n    def register_user(email, password):\n        register_payload = {\n            \"email\": email,\n            \"password\": password,\n            \"name\": \"Test User\"\n        }\n        response = requests.post(f\"{BASE_URL}/auth/register\", json=register_payload, timeout=TIMEOUT)\n        assert response.status_code == 201\n        return response.json()\n\n    # Helper function to login and return accessToken and refreshToken\n    def login_user(email, password):\n        login_payload = {\n            \"email\": email,\n            \"password\": password\n        }\n        response = requests.post(f\"{BASE_URL}/auth/login\", json=login_payload, timeout=TIMEOUT)\n        return response\n\n    # Attempt to login first\n    login_resp = login_user(USER_EMAIL, USER_PASSWORD)\n    if login_resp.status_code == 401:\n        # User likely doesn't exist, register then login again\n        register_user(USER_EMAIL, USER_PASSWORD)\n        login_resp = login_user(USER_EMAIL, USER_PASSWORD)\n\n    assert login_resp.status_code == 200, f\"Login failed with status {login_resp.status_code}, body: {login_resp.text}\"\n    tokens = login_resp.json()\n    access_token = tokens.get(\"accessToken\")\n    refresh_token = tokens.get(\"refreshToken\")\n    assert access_token, \"No accessToken in login response\"\n    assert refresh_token, \"No refreshToken in login response\"\n\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n\n    # Create a new workspace to ensure user has at least one workspace\n    workspace_name = f\"test-workspace-{uuid.uuid4()}\"\n    workspace_slug = f\"test-workspace-{uuid.uuid4()}\"\n    create_workspace_payload = {\n        \"name\": workspace_name,\n        \"slug\": workspace_slug\n    }\n\n    ws_create_resp = requests.post(f\"{BASE_URL}/api/workspaces\", headers=headers, json=create_workspace_payload, timeout=TIMEOUT)\n    assert ws_create_resp.status_code == 201, f\"Workspace creation failed: {ws_create_resp.text}\"\n    workspace = ws_create_resp.json()\n    workspace_id = workspace.get(\"id\")\n    assert workspace_id, \"Created workspace has no id\"\n\n    try:\n        # Test GET /api/workspaces endpoint\n        ws_list_resp = requests.get(f\"{BASE_URL}/api/workspaces\", headers=headers, timeout=TIMEOUT)\n        assert ws_list_resp.status_code == 200, f\"GET /api/workspaces failed: {ws_list_resp.text}\"\n        ws_list = ws_list_resp.json()\n        assert isinstance(ws_list, list), \"Response is not a list\"\n        # The created workspace should be in the list\n        assert any(w.get(\"id\") == workspace_id for w in ws_list), \"Created workspace not found in workspace list\"\n\n        # Removed members endpoints tests - not part of PRD\n\n        # 4. Test authentication and authorization middleware:\n        # GET /api/workspaces without Authorization header -> expect 401\n        ws_no_auth_resp = requests.get(f\"{BASE_URL}/api/workspaces\", timeout=TIMEOUT)\n        assert ws_no_auth_resp.status_code == 401, f\"GET /api/workspaces without auth should 401, got {ws_no_auth_resp.status_code}\"\n\n        # 5. Test error handling for invalid workspace ID for GET\n        invalid_id = \"invalid-id-1234\"\n        ws_invalid_resp = requests.get(f\"{BASE_URL}/api/workspaces/{invalid_id}\", headers=headers, timeout=TIMEOUT)\n        assert ws_invalid_resp.status_code == 404, f\"GET /api/workspaces/{invalid_id} should return 404, got {ws_invalid_resp.status_code}\"\n\n        # 6. Test error handling for invalid workspace ID for PUT\n        put_payload = {\"name\": \"newname\", \"slug\": \"newslug\"}\n        ws_put_invalid_resp = requests.put(f\"{BASE_URL}/api/workspaces/{invalid_id}\", headers=headers, json=put_payload, timeout=TIMEOUT)\n        assert ws_put_invalid_resp.status_code == 404, f\"PUT /api/workspaces/{invalid_id} should return 404, got {ws_put_invalid_resp.status_code}\"\n\n        # 7. Test error handling for invalid workspace ID for DELETE\n        ws_del_invalid_resp = requests.delete(f\"{BASE_URL}/api/workspaces/{invalid_id}\", headers=headers, timeout=TIMEOUT)\n        assert ws_del_invalid_resp.status_code == 404, f\"DELETE /api/workspaces/{invalid_id} should return 404, got {ws_del_invalid_resp.status_code}\"\n\n        # 8. Test health check endpoint GET /\n        health_resp = requests.get(f\"{BASE_URL}/\", timeout=TIMEOUT)\n        assert health_resp.status_code == 200, f\"Health check GET / failed with {health_resp.status_code}\"\n        health_text = health_resp.text.lower()\n        assert \"hello\" in health_text or \"world\" in health_text, \"Health check response unexpected\"\n\n        # 9. Test Redis connectivity endpoint GET /test-redis\n        redis_resp = requests.get(f\"{BASE_URL}/test-redis\", timeout=TIMEOUT)\n        # Accept 200 or 500 as per description\n        assert redis_resp.status_code in (200, 500), f\"GET /test-redis unexpected status {redis_resp.status_code}\"\n\n        # 10. Test error handling endpoint GET /error\n        error_resp = requests.get(f\"{BASE_URL}/error\", timeout=TIMEOUT)\n        assert error_resp.status_code == 500, f\"GET /error expected status 500, got {error_resp.status_code}\"\n        error_body = error_resp.json()\n        assert \"error\" in error_body, \"GET /error response missing 'error' field\"\n    finally:\n        # Clean up: delete the workspace created\n        delete_resp = requests.delete(f\"{BASE_URL}/api/workspaces/{workspace_id}\", headers=headers, timeout=TIMEOUT)\n        # Deletion may return 204 or possibly 404 if already deleted; accept both\n        assert delete_resp.status_code in (204, 404), f\"Workspace deletion unexpected status {delete_resp.status_code}\"\n\ntest_get_api_workspaces_list_all_workspaces_for_authenticated_user()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 115, in <module>\n  File \"<string>\", line 38, in test_get_api_workspaces_list_all_workspaces_for_authenticated_user\nAssertionError: Login failed with status 404, body: {\"error\":\"Route not found\"}\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.172Z",
    "modified": "2026-02-18T12:38:24.396Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "e8ae559b-184b-4a43-9b6e-16fa970cc984",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC009-post api invitations send invitation to join workspace",
    "description": "Test the POST /api/invitations endpoint with valid email, workspaceId, and role to ensure it returns 201 status with the created invitation object.",
    "code": "import requests\nimport uuid\nimport random\nimport string\n\nbase_url = \"http://localhost:8000\"\ntimeout = 30\n\nauth_username = \"test@test.com\"\n\ndef get_access_token():\n    # Login to get accessToken and refreshToken\n    login_url = f\"{base_url}/auth/login\"\n    login_payload = {\n        \"email\": auth_username,\n        \"password\": \"password123\"  # Assuming a default password for the test user\n    }\n    try:\n        r = requests.post(login_url, json=login_payload, timeout=timeout)\n        r.raise_for_status()\n        tokens = r.json()\n        return tokens.get(\"accessToken\")\n    except Exception as e:\n        raise RuntimeError(f\"Failed to login and get access token: {e}\")\n\ndef create_workspace(access_token):\n    url = f\"{base_url}/api/workspaces\"\n    slug = ''.join(random.choices(string.ascii_lowercase + string.digits, k=8))\n    payload = {\n        \"name\": \"Test Workspace \" + str(uuid.uuid4()),\n        \"slug\": slug\n    }\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n    r = requests.post(url, json=payload, headers=headers, timeout=timeout)\n    r.raise_for_status()\n    return r.json()\n\ndef delete_workspace(access_token, workspace_id):\n    url = f\"{base_url}/api/workspaces/{workspace_id}\"\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n    r = requests.delete(url, headers=headers, timeout=timeout)\n    if r.status_code not in (204, 404):\n        r.raise_for_status()\n\ndef test_post_api_invitations_send_invitation_to_join_workspace():\n    access_token = get_access_token()\n    headers = {\n        \"Authorization\": f\"Bearer {access_token}\"\n    }\n    workspace = None\n    invitation_id = None\n    try:\n        # Create a workspace to invite someone to\n        workspace = create_workspace(access_token)\n        workspace_id = workspace.get(\"id\")\n        assert workspace_id, \"Workspace creation did not return an id\"\n\n        # Prepare invitation payload\n        invitation_email = f\"invitee_{uuid.uuid4().hex[:8]}@example.com\"\n        invitation_role = \"member\"\n        invitation_url = f\"{base_url}/api/invitations\"\n        invitation_payload = {\n            \"email\": invitation_email,\n            \"workspaceId\": workspace_id,\n            \"role\": invitation_role\n        }\n\n        # Send POST /api/invitations\n        r = requests.post(invitation_url, json=invitation_payload, headers=headers, timeout=timeout)\n        assert r.status_code == 201, f\"Expected status code 201, got {r.status_code}\"\n        invitation = r.json()\n        assert invitation.get(\"id\"), \"Invitation response missing 'id'\"\n        assert invitation.get(\"email\") == invitation_email, \"Invitation email mismatch\"\n        assert invitation.get(\"workspaceId\") == workspace_id, \"Invitation workspaceId mismatch\"\n        assert invitation.get(\"role\") == invitation_role, \"Invitation role mismatch\"\n\n        invitation_id = invitation.get(\"id\")\n\n    finally:\n        # Cleanup: delete invitation if exists\n        if invitation_id:\n            try:\n                del_url = f\"{base_url}/api/invitations/{invitation_id}\"\n                del_resp = requests.delete(del_url, headers=headers, timeout=timeout)\n                if del_resp.status_code not in (204, 404):\n                    del_resp.raise_for_status()\n            except Exception:\n                pass\n\n        # Cleanup: delete workspace if exists\n        if workspace and workspace.get(\"id\"):\n            try:\n                delete_workspace(access_token, workspace[\"id\"])\n            except Exception:\n                pass\n\ntest_post_api_invitations_send_invitation_to_join_workspace()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"<string>\", line 20, in get_access_token\n  File \"/var/task/requests/models.py\", line 1024, in raise_for_status\n    raise HTTPError(http_error_msg, response=self)\nrequests.exceptions.HTTPError: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n\nDuring handling of the above exception, another exception occurred:\n\nTraceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 101, in <module>\n  File \"<string>\", line 50, in test_post_api_invitations_send_invitation_to_join_workspace\n  File \"<string>\", line 24, in get_access_token\nRuntimeError: Failed to login and get access token: 404 Client Error: Not Found for url: http://localhost:8000/auth/login\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.178Z",
    "modified": "2026-02-18T12:37:58.156Z"
  },
  {
    "projectId": "48a07169-d9da-4909-bf1f-9d6986f9dc59",
    "testId": "b8c06c8b-ab35-4a80-915c-23ddf41bcb38",
    "userId": "d4982478-8071-7067-b4e3-4db0f33776a0",
    "title": "TC010-get root health check endpoint",
    "description": "Test the GET / endpoint to verify it returns 200 status with a Hello World message indicating server is running.",
    "code": "import requests\n\ndef test_tc010_get_root_health_check_endpoint():\n    base_url = \"http://localhost:8000\"\n    url = f\"{base_url}/\"\n    try:\n        response = requests.get(url, timeout=30)\n        assert response.status_code == 200, f\"Expected status 200, got {response.status_code}\"\n        # The body should contain a \"Hello World\" message indicating server is running\n        # Accept either plain text or JSON with such message\n        try:\n            data = response.json()\n            assert any(\"hello\" in str(v).lower() and \"world\" in str(v).lower() for v in data.values()), \\\n                \"Response JSON does not contain 'Hello World' message\"\n        except ValueError:\n            # Not JSON, check text body\n            body_text = response.text.lower()\n            assert \"hello\" in body_text and \"world\" in body_text, \"Response text does not contain 'Hello World'\"\n    except requests.RequestException as e:\n        assert False, f\"Request failed: {e}\"\n\ntest_tc010_get_root_health_check_endpoint()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 22, in <module>\n  File \"<string>\", line 8, in test_tc010_get_root_health_check_endpoint\nAssertionError: Expected status 200, got 404\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-18T12:36:52.183Z",
    "modified": "2026-02-18T12:37:57.756Z"
  }
]
