# ..

**Add AFTER all routes:**

```jsx
app.use((err, req, res, next) => {
  console.error('Error:', err.message)
  res.status(500).json({ error: err.message })
})
```

**Test it by breaking something:**

```jsx
app.get('/error', (req, res) => {
  throw new Error('Something broke!')
})
```

**Visit:** `http://localhost:8000/error`

**✅ Checkpoint:** Do you see `{"error":"Something broke!"}`?

**Understand:**

```
Q: Why 4 parameters (err, req, res, next)?
A: Express treats 4-param functions as error handlers

Q: Why put it at the end?
A: Catches errors from all routes above it

Q: What is next()?
A: Passes control to next middleware (not needed in error handler)
```

---

- [x]  **Step 5: Switch to TypeScript (30 min)**

**Why TypeScript?**
- Catches bugs before running code
- Better autocomplete in VS Code
- Industry standard for Node.js

```bash
npm install -D typescript @types/node @types/express
npx tsc --init
```

**Create folder structure:**

```bash
mkdir src
mv index.js src/app.ts  # Rename to .ts
```

**Convert your code to TypeScript:**

```tsx
import express, { Request, Response, NextFunction } from 'express'
import cors from 'cors'

const app = express()

app.use(cors({ origin: 'http://localhost:3000', credentials: true }))
app.use(express.json())

app.get('/', (req: Request, res: Response) => {
  res.json({ message: 'Hello World' })
})

// Error handler
app.use((err: Error, req: Request, res: Response, next: NextFunction) => {
  console.error('Error:', err.message)
  res.status(500).json({ error: err.message })
})

app.listen(8000, () => {
  console.log('Server running on http://localhost:8000')
})
```

**Install dev runner:**

```bash
npm install -D ts-node-dev
```

**Update package.json scripts:**

```json
{
  "scripts": {
    "dev": "ts-node-dev --respawn src/app.ts"
  }
}
```

**Run:**

```bash
npm run dev
```

**✅ Checkpoint:** Server still works?

---

- [x]  **Step 6: Environment Variables (15 min)**

**Why?** Secrets shouldn’t be in code (they’ll go to GitHub!)

```bash
npm install dotenv
```

**Create `.env` file:**

```
PORT=8000
```

**Create `.env.example`** (this CAN go to GitHub):

```
PORT=8000
```

**Update app.ts:**

```tsx
import dotenv from 'dotenv'
dotenv.config()

const PORT = process.env.PORT || 8000

app.listen(PORT, () => {
  console.log(`Server running on http://localhost:${PORT}`)
})
```

**Create `.gitignore`:**

```
node_modules/
.env
dist/
```

**Understand:**

```
Q: Why separate .env and .env.example?
A: .env has real secrets (never commit)
   .env.example shows what variables are needed (safe to commit)

Q: What does dotenv.config() do?
A: Reads .env file and puts values in process.env
```

---

## **PHASE 2: DATABASE (2 hours)**

- [x]  **Step 1: Understand Database Concepts (30 min)**

**Before writing code, understand:**

**What is PostgreSQL?**
- Relational database (tables with rows and columns)
- Like Excel but powerful, fast, handles millions of rows
- Industry standard (used by Instagram, Uber, Netflix)

**What is an ORM?**
- Object-Relational Mapping
- Write JavaScript instead of SQL
- Example: `user.create({name: 'John'})` instead of `INSERT INTO users...`

**What is Prisma?**
- Modern ORM for Node.js
- Auto-generates types for TypeScript
- Handles migrations (changing database structure)

**What is Supabase?**
- Hosted PostgreSQL (you don’t manage server)
- Free tier (500MB database)
- Gives you a connection URL

---

- [x]  **Step 2: Setup Supabase (15 min)**
1. Go to supabase.com
2. Sign up with GitHub
3. Create project: “yander-dev”
4. Wait 2 minutes for database
5. Settings → Database → Copy “Connection string”
6. Add to `.env`:
    
    ```
    DATABASE_URL="postgresql://postgres:[PASSWORD]@db.[PROJECT].supabase.co:5432/postgres"
    ```
    

---

- [x]  **Step 3: Install and Initialize Prisma (15 min)**

```bash
npm install @prisma/client
npm install -D prisma

npx prisma init
```

**This creates:**
- `prisma/schema.prisma` (database structure)
- Updates `.env` with DATABASE_URL placeholder

**Understand the schema file:**

```
// This is like a blueprint for your database

generator client {
  provider = "prisma-client-js"  // Generates JS/TS code
}

datasource db {
  provider = "postgresql"  // Using PostgreSQL
  url      = env("DATABASE_URL")  // From .env file
}
```

---

- [x]  **Step 4: Create Your First Model (30 min)**

**Think about what you need for auth:**
- Users need: email, password, name
- Email must be unique
- Need timestamps (when created)

**Add to `schema.prisma`:**

```
model User {
  id           String   @id @default(uuid())
  email        String   @unique
  passwordHash String
  name         String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
}
```

**Understand each line:**

```
@id                  = Primary key (unique identifier)
@default(uuid())     = Auto-generate unique ID
@unique              = No duplicate emails allowed
DateTime             = Stores date and time
@default(now())      = Set to current time when created
@updatedAt           = Auto-update when record changes
```

**Create the database table:**

```bash
npx prisma migrate dev --name create_users
```

**What this does:**
1. Reads your schema
2. Generates SQL to create table
3. Runs SQL on your database
4. Generates TypeScript types

**View your database:**

```bash
npx prisma studio
```

Opens browser at localhost:5555 - you can see your empty `User` table!

---

- [x]  **Step 5: Use Prisma in Your Code (30 min)**

**Create `src/lib/prisma.ts`:**

```tsx
import { PrismaClient } from '@prisma/client'

export const prisma = new PrismaClient()
```

**Create a test route in `app.ts`:**

```tsx
import { prisma } from './lib/prisma'

app.post('/users', async (req: Request, res: Response) => {
  try {
    const user = await prisma.user.create({
      data: {
        email: req.body.email,
        name: req.body.name,
        passwordHash: 'temp123'  // We'll hash properly later
      }
    })
    res.json(user)
  } catch (error: any) {
    res.status(400).json({ error: error.message })
  }
})
```